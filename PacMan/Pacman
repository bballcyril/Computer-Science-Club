int x = 100; //X Coordinate of Pac-Man
int y = 35; //Y Coordinate of Pac-Man
int d = 15; //Diameter of Pacman
int r = d/2; //Radius of Pacman (As so not to always type d/2)
float pt1 = radians(50); float pt2 = radians(310);
int counter = 0; //Timer for how Pac-Man moving mouth
boolean wLeft; //Booleans that become true if wall is blocking in that direction
boolean wRight; //w stands for Wall
boolean wUp;
boolean wDown;
int numBoxesW = 20; //Number of Boxes in Width
int numBoxesH = 20; //Number of Boxes in Height
int lineCounter1; //Used in for loop for creating lines in box
int lineCounter2; //Used in for loop for creating lines in box
float[] linesW = new float[numBoxesW+1]; //Array holding each box corners' X coordinate
float[] linesH = new float[numBoxesH+1]; //Array holding each box corners' Y coordinate
float boxHeight = 600; //Name says it all
float boxWidth = 480; //Name says it all
float boxStartX = 25; //Starting X of top left corner
float boxStartY = 20; //Starting Y of top left corner
float betwX = boxWidth/numBoxesW; //Space between boxes horizontally or sideways
float betwY = boxHeight/numBoxesH; //Space between boxes vertically or up and down

boolean isDown; boolean isUp; boolean isLeft; boolean isRight; //Booleans determining which direction pac-man is facing

void setup(){
  size(530, 650);
}

void draw(){ 
   background(0);
  frameRate(120);
  lineCounter1 = 0;
  lineCounter2 = 0;
  if(x == boxStartX+r){
    wLeft = true;
  }
  if(x == boxStartX+boxWidth-r){
    wRight = true; 
  }
  if(y == boxStartY+r){
    wUp = true; 
  }
  if(y == boxStartY+boxHeight-r){
    wDown = true; 
  }
    counter++;
    if(counter < 60){
       pt1 -= radians(1);
       pt2 += radians(1);
    }else if(counter > 60 && counter < 120){
       pt1 += radians(1);
       pt2 -= radians(1);
    }else if(counter > 120){
       counter = 0; 
    }
    fill(255, 255, 0);
    noStroke();
  arc(x, y, d, d, pt1, pt2);
 if(keyPressed){
  if(keyCode == LEFT){
    isLeft = true; isRight = false; isUp = false; isDown = false;
    pt1 = radians(230); pt2 = radians(490); counter = 0;
  }
  if(keyCode == RIGHT){
    isLeft = false; isRight = true; isUp = false; isDown = false;
    pt1 = radians(50); pt2 = radians(310); counter = 0;
  }
  if(keyCode == UP){
    isLeft = false; isRight = false; isUp = true; isDown = false;
    pt1 = radians(320); pt2 = radians(580); counter = 0;
  }
  if(keyCode == DOWN){
    isLeft = false; isRight = false; isUp = false; isDown = true;
    pt1 = radians(140); pt2 = radians(400); counter = 0;
  }
 }
 if(isLeft && !wLeft){
    x--; 
 }
 if(isRight && !wRight){
    x++; 
 }
 if(isUp && !wUp){
    y--; 
 }
 if(isDown && !wDown){
    y++; 
 }
 if(wLeft){
   x++;
   wLeft = false;
 }
  if(wRight){
   x--;
   wRight = false;
 }
  if(wUp){
   y++;
   wUp = false;
 }
  if(wDown){
   y--;
   wDown = false;
 }
 stroke(255, 0, 0);
 strokeWeight(2);

for(float i = boxStartY;i <= boxHeight+boxStartY;i+=betwY){ //Y
  line(boxStartX, i, boxWidth+boxStartX, i);
  linesH[lineCounter1] = i;
  lineCounter1++;
  
}
for(float f = boxStartX;f <= boxWidth+boxStartX;f+=betwX){ //X
  line(f, boxStartY, f, boxHeight+boxStartY);
  linesW[lineCounter2] = f;
  lineCounter2++;
}
  fill(0,255, 0);
  noStroke();
  //border(blocked direction, blocked start point, blocked end point, point of blocking);
  //1-LEFT, 2-RIGHT, 3-UP, 4-DOWN
  //The blocked lines are darkly colored, don't know how to change it to a different color
  //BorderIO boxes both inside and outside of border
  //IO stands for INSIDE/OUTSIDE if you're wondering
  //When you use border IO, it doesn't matter if you choose 1 or 2, and 3 or 4
  
  //Spawn Box - Allowed Pacman to enter
  //Borders are blocked inside and outside
  borderIO(1, 9, 11, 12);
  borderIO(2, 9, 11, 8);
  borderIO(3, 8, 12, 11);
  borderIO(4, 8, 9, 9);
  borderIO(4, 11, 12, 9);
  borderIO(1, 9, 10, 9);
  borderIO(1, 9, 10, 11);
  
  //Top Left
  border(2, 1, 5, 1);
  border(1, 1, 5, 5);
  border(4, 1, 5, 1);
  border(3, 1, 5, 5);
  //Top Right
  border(1, 1, 5, 19);
  border(2, 1, 5, 15);
  border(4, 15, 19, 1);
  border(3, 15, 19, 5);
  //Bottom Left
  border(2, 15, 19, 1);
  border(1, 15, 19, 5);
  border(4, 1, 5, 15);
  border(3, 1, 5, 19);
  //Bottom Right
  border(2, 15, 19, 15);
  border(1, 15, 19, 19);
  border(3, 15, 19, 19);
  border(4, 15, 19, 15);
  
  
}

void walls(int x, int y, int numX, int numY){
  rect(linesW[x], linesH[y], betwX*numX, betwY*numY);
}
void border(int direction, int block1, int block2, int point){ //1 = left, 2 = right, 3 = Up, 4 = down
    if(direction == 1){
      if(y >= linesH[block1]-r && y <= linesH[block2]+r){
         if(x == linesW[point]+r){
           wLeft = true;
         }
      }
      stroke(0, 255, 0);
      stroke(15);
      line(linesW[point], linesH[block1], linesW[point], linesH[block2]);
    }
        if(direction == 2){
      if(y >= linesH[block1]-r && y <= linesH[block2]+r){
         if(x == linesW[point]-r){
           wRight = true;
         }
      }
      stroke(0, 255, 0);
      stroke(15);
      line(linesW[point], linesH[block1], linesW[point], linesH[block2]);
    }
        if(direction == 3){
      if(x >= linesW[block1]-r && x <= linesW[block2]+r){
         if(y == linesH[point]+r){
           wUp = true;
         }
      }
      stroke(0, 255, 0);
      stroke(15);
      line(linesW[block1], linesH[point], linesW[block2], linesH[point]);
    }
        if(direction == 4){
      if(x >= linesW[block1]-r && x <= linesW[block2]+r){
         if(y == linesH[point]-r){
           wDown = true;
         }
      }
      stroke(0, 255, 0);
      stroke(15);
      line(linesW[block1], linesH[point], linesW[block2], linesH[point]);
    }
}

void borderIO(int a, int b, int c, int d){
     if(a == 1 || a == 3){
        border(a, b, c, d);
        border(a+1, b, c, d);
     }
     if(a == 2 || a == 4){
        border(a, b, c, d);
        border(a-1, b, c, d);
     }
}
